'use strict';
import {
  Model
} from 'sequelize';
import { InvoiceType, RecurrenceInterval, DiscountType, InvoiceStatus } from '../utils/types.js';

export default (sequelize, DataTypes) => {
  class Invoice extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method automatically.
     */
    static associate(models) {
      // define association here
      Invoice.belongsTo(models.User, { 
        foreignKey: 'userId', 
        as: 'creator' 
      });
      
      // Invoice belongs to a client
      Invoice.belongsTo(models.Client, { 
        foreignKey: 'clientId', 
        as: 'client' 
      });
      
      // Self-referential for recurring invoices
      Invoice.belongsTo(models.Invoice, { 
        foreignKey: 'parentInvoiceId', 
        as: 'parentInvoice' 
      });
      
      Invoice.hasMany(models.Invoice, { 
        foreignKey: 'parentInvoiceId', 
        as: 'recurringInvoices' 
      });
      
      // Invoice can have many transactions (payments)
      Invoice.hasMany(models.Transaction, { 
        foreignKey: 'invoiceId', 
        as: 'transactions' 
      });
    }

    isOverdue() {
      return this.status !== InvoiceStatus.paid && 
             this.status !== InvoiceStatus.cancelled && 
             new Date() > new Date(this.dueDate);
    }
    
    isExpired() {
      return this.expiryDate && new Date() > new Date(this.expiryDate);
    }
    
    calculateTotals() {
      const items = this.items || [];
      let subtotal = 0;
      
      // Calculate subtotal from items
      items.forEach(item => {
        subtotal += (item.quantity || 1) * (item.amount || 0);
      });
      
      // Apply discount
      let discountAmount = 0;
      if (this.discountType === DiscountType.percentage) {
        discountAmount = (subtotal * (this.discountValue || 0)) / 100;
      } else if (this.discountType === DiscountType.fixed) {
        discountAmount = this.discountValue || 0;
      }
      
      const afterDiscount = subtotal - discountAmount;
      const totalAmount = afterDiscount;
      
      return {
        subtotal,
        discountAmount,
        totalAmount,
        remainingAmount: totalAmount - (this.paidAmount || 0)
      };
    }
    
    async markAsPaid(transactionId = null) {
      const totals = this.calculateTotals();
      await this.update({
        status: 'paid',
        paidAmount: totals.totalAmount,
        remainingAmount: 0,
        paidAt: new Date()
      });
      
      if (this.invoiceType === InvoiceType.recurring && !this.isAutoGenerated) {
        await this.generateNextRecurringInvoice();
      }
    }
    
    async generateNextRecurringInvoice() {
      if (this.invoiceType !== InvoiceType.recurring || !this.nextInvoiceDate) {
        return null;
      }
      
      // Calculate next invoice date
      let nextDate = new Date(this.nextInvoiceDate);
      const currentDate = new Date();
      
      if (nextDate <= currentDate) {
        const intervals = {
          'weekly': 7 * 24 * 60 * 60 * 1000,
          'monthly': 30 * 24 * 60 * 60 * 1000, // Approximate
          'quarterly': 90 * 24 * 60 * 60 * 1000,
          'yearly': 365 * 24 * 60 * 60 * 1000
        };
        
        nextDate = new Date(currentDate.getTime() + intervals[this.recurrenceInterval]);
      }
      
      // Generate invoice number
      const invoiceNumber = await this.constructor.generateInvoiceNumber(this.userId);
      
      // Create new invoice
      const newInvoice = await this.constructor.create({
        invoiceNumber,
        userId: this.userId,
        clientId: this.clientId,
        parentInvoiceId: this.id,
        invoiceType: InvoiceType.recurring,
        recurrenceInterval: this.recurrenceInterval,
        recurrenceCount: this.recurrenceCount,
        nextInvoiceDate: nextDate,
        title: this.title,
        description: this.description,
        items: this.items,
        currency: this.currency,
        subtotal: this.subtotal,
        taxRate: this.taxRate,
        taxAmount: this.taxAmount,
        discountType: this.discountType,
        discountValue: this.discountValue,
        discountAmount: this.discountAmount,
        totalAmount: this.totalAmount,
        acceptedTokens: this.acceptedTokens,
        acceptsFiatPayment: this.acceptsFiatPayment,
        paymentInstructions: this.paymentInstructions,
        status: InvoiceStatus.draft,
        issueDate: new Date(),
        dueDate: new Date(Date.now() + (30 * 24 * 60 * 60 * 1000)), // 30 days from now
        notes: this.notes,
        isAutoGenerated: true,
        remainingAmount: this.totalAmount
      });
      
      // Update current invoice's next date
      await this.update({ nextInvoiceDate: nextDate });
      
      return newInvoice;
    }
    
    static async generateInvoiceNumber(userId) {
      const year = new Date().getFullYear();
      const prefix = `INV-${year}-`;
      
      // Find the last invoice number for this user and year
      const lastInvoice = await this.findOne({
        where: {
          userId,
          invoiceNumber: {
            [Op.like]: `${prefix}%`
          }
        },
        order: [['invoiceNumber', 'DESC']]
      });
      
      let nextNumber = 1;
      if (lastInvoice) {
        const lastNumber = parseInt(lastInvoice.invoiceNumber.split('-').pop());
        nextNumber = lastNumber + 1;
      }
      
      return `${prefix}${nextNumber.toString().padStart(3, '0')}`;
    }
    
    static async findOverdueInvoices() {
      return await this.findAll({
        where: {
          status: {
            [Op.notIn]: ['paid', 'cancelled']
          },
          dueDate: {
            [Op.lt]: new Date()
          }
        },
        include: [
          { model: this.sequelize.models.Client, as: 'client' },
          { model: this.sequelize.models.User, as: 'creator' }
        ]
      });
    }
  }

  Invoice.init({
    invoiceNumber: DataTypes.STRING,
    userId: DataTypes.BIGINT,
    clientId: DataTypes.BIGINT,
    invoiceType: DataTypes.ENUM(
      InvoiceType.oneTime,
      InvoiceType.recurring
    ),
    parentInvoiceId: DataTypes.BIGINT,
    recurrenceInterval: DataTypes.ENUM(
      RecurrenceInterval.weekly,
      RecurrenceInterval.monthly,
      RecurrenceInterval.quarterly,
      RecurrenceInterval.yearly
    ),
    recurrenceCount: DataTypes.INTEGER,
    nextInvoiceDate: DataTypes.DATE,
    title: DataTypes.STRING,
    description: DataTypes.TEXT,
    items: DataTypes.JSONB,
    currency: DataTypes.STRING,
    subTotal: DataTypes.DECIMAL(20, 9),
    discountType: DataTypes.ENUM(
      DiscountType.percentage,
      DiscountType.fixed
    ),
    discountValue: DataTypes.DECIMAL(20, 9),
    discountAmount: DataTypes.DECIMAL(20, 9),
    totalAmount: DataTypes.DECIMAL(20, 9),
    acceptedTokens: DataTypes.JSONB,
    acceptsFiatPayment: DataTypes.BOOLEAN,
    status: DataTypes.ENUM(
      InvoiceStatus.draft,      // 'draft'
      InvoiceStatus.sent,       // 'sent'
      InvoiceStatus.viewed,     // 'viewed'
      InvoiceStatus.partial,    // 'partial_paid'
      InvoiceStatus.paid,       // 'paid'
      InvoiceStatus.overdue,    // 'overdue'
      InvoiceStatus.cancelled   // 'cancelled'
    ),
    issueDate: DataTypes.DATE,
    dueDate: DataTypes.DATE,
    expiryDate: DataTypes.DATE,
    paidAt: DataTypes.DATE,
    sentAt: DataTypes.DATE,
    paidAmount: DataTypes.DECIMAL(20, 9),
    remainingAmount: DataTypes.DECIMAL(20, 9),
    notes: DataTypes.TEXT,
    metadata: DataTypes.JSONB,
    isAutoGenerated: DataTypes.BOOLEAN,

  }, {
    sequelize,
    modelName: 'Invoice',
  });
  return Invoice;
};